fork() --> crea un figlio, da il valore del figlio quando è nel padre, da valore 0 quando è nel figlio

whait(&status) --> restituisce lo stato del figlio terminato o bloccato da un segnale, ECHILD significa che il padre non ha figli

exit(status) --> termina un processo, si usa 0 per EXIT_SUCCESS e 1 per EXIT_FAILLURE

execve(pathname, argv, envp) --> serve a caricare un nuovo programma nella memoria del processo, restituisce -1 solo se finisce, altrimenti esegue il programma

sleep(n) --> interrompe il processo per n secondi

atexit(function) --> esegue la funzione alla fine del processo, è di tipo LIFO, quindi l'ultimo inserito è il primo eseguito

waitpid(pid_t pid, int *status, int options) --> sospende l'esecuzione di un processo finché il figlio indicato non cambia stato

getpid() --> ottiene l'ID del processo

getppid() --> ottiene l'ID del processo padre

execle(const char *pathname, const char *arg)    |
execlp(const char *filename, const char *arg)    |
execl(const char *pathname, const char *arg)     |- chiedono al processo figlio di eseguire un altro programma, ognuna in modo diverso e fanno parte di exec()
execle(const char *pathname, const char *arg)    |
execve(const char *pathname, char *const argv[]) |

system() --> chiama un programma per eseguire un comando da shell

fflush(stdout) --> Durante la stampa (ad es. printf), l'output viene inserito in un buffer e non può essere scritto nella console finché non viene visualizzato un carattere di nuova riga. Per assicurarsi che tutto nel buffer venga scritto sulla console, è possibile utilizzare fflush(stdout).

errExit(const char *str) --> esce creando un messaggio di errore

perror(const char *str) --> stampa la stringa inserita + il messaggio di errore

ftell(fp) --> ritorna il numero di byte del file fp (nel caso di file di testo il numero di parole) su cui si trova l'offset

fseek(FILE *stream, long int offset, int where) --> imposta la posizione del file di STREAM all'offset specificato

fyok(pathname, prog_id) --> crea una chiave sulla base di un file esistente. "prog_id" serve per creare una nuova chiave sulla base dello stesso file, cambiandola si cambia chiave

msgsnd(int, void *, size_t, int maschera di bit[bloccante solo quando la coda è piena]) --> scrive un messaggio sulla coda di messaggi (non ha senso spedire un puntatore)  |
msgrcv(int, void *, size_t, long(getpid() [per leggere la coda come una rubrica del padre]), int maschera di bit) --> riceve il messaggio dalla coda di messaggi            |- system call per le I\O dei messaggi. (il parametro long ci deve sempre essere per identificarne il tipo)

[ricordarsi di sincronizzare le operazioni che vengono fatte dai processi, chi legge aspetta lo scrittore senza occupare memoria]

memset(char *[], char, int) --> assegna il char nella stringa puntata per int posizioni a partire dalla pos. 0 sostituendo la stringa passata

signal(int sig, void (*func)(int)) --> gesisce il segnale sig con il metodo *func

strlen(char *s[]) --> ritorna la lunghezza di s

read(int socket, void *buf, ssize_t N) --> legge quello che è stato scritto sulla pipe e lo inserisce in buf grande N byte se socket è su 0

write(int socket, void *buf, ssize_t N) --> scrive N byte del contenuto di buf nella pipe con socket su 1

mkfifo(char* path, S_IRUSR | S_IWUSR) --> crea un file che si comporta come una pipe, path crea il nome della pipe il secondo dichiara se di lettura o scrittura (o entrambe)

[ATTESA NON ATTIVA: es. sleep, attese che non tengono impegnate la CPU]

semget(key_t key, int sems, int semflg) --> crea un array di semafori, sems è il numero di semafori

int shmget(key_t key, size_t size (VEDERE I DIVERSI TIPI DI DICHIARAZIONE), int shmflg) --> ottiene ID parte di memoria condivisa

void *shmat(int shmid, const void *shmaddr, int shmflg) --> fa un attack alla parte di memoria condivisa

int shmdt(const void *shmaddr) --> fa il detack del segmento di memoria condivisa, il processo non potrà più riferirsi alla memoria condivisa ma il segmento continuerà ad esistere

int shmctl(int shmid, int cmd, struct shmid_ds *buf) --> rimuove il segmento di memoria condivisa, ma non la rimuoverà del tutto finché tutti i processi non rilasceranno quella parte

shmctl(id, IPC_RMID, NULL) --> in questo modo elimina l'oggetto parlando di code di messaggi

snprintf(stringa_1, sizeof(msg), "%s", msg) --> scrivo il mio valore all'interno della memoria condivisa

atoi(char *) --> converte una string ad un int

[Nel progetto aggiungere #define _GNU_SOURCE]

#include <stdio.h> --> I/O operations

#include <stdlib.h> --> include diverse funzioni standard come gestione memoria, generazione numeri random, conversioni int, comunicazioni tra ambienti diversi, ricerche, ordinamenti e conversioni

#include <unistd.h> -->  contiene funzioni wrapper delle chiamate di sistema basilari del sistema operativo, come fork, pipe e primitive I/O (read, write, close etc.)

#include <errno.h> --> definisce la macro errno per vedere il numero di errori

#include <time.h> --> visualizza e gestisce informazioni riguardanti il tempo

#include <string.h> --> serve per gestire stringhe e array

#include <sys/types.h> --> contiene collezioni di typedef, esempio size_t, key_t, u_int etc...

#include <sys/wait.h> --> serve per la system call wait

#include <sys/ipc.h> --> contiene le definizioni per la struttura di accesso alla comunicazione tra processi

#include <sys/sem.h> --> contiene le definizioni necessarie per eseguire i semafori

#include <sys/sysinfo.h> --> contiene le definizioni per le informazioni di sistema

[IPC = inter-Process Communication ]

msgget (key, IPC_CREAT | S_IRUSR | S_IWUSR) --> ritorna il valore del messaggio che ha come identificatore KEY, se su key gli inseriamo IPC_CREAT lui creerà un nuovo oggetto, specificando IPC_EXCL si assicura si essere il creatore

ftok(char *pathname, int proj) --> crea una chiave unica per oggetti IPC